from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from .models import Poll, Choice, Vote
from django.contrib import messages
from django.db import IntegrityError

#the user dashboard main function
@login_required
def dashboard(request):
    #get all of the user polls
    polls = Poll.objects.filter(created_by_id=request.user.id)

    #loop on them to generate the link and save it as a variable
    for poll in polls:
        poll.shareable_link = poll.generate_link(request)

    #create the context data that will be sent
    context = {
        "username": request.user.username,
        "polls": polls
    }
    return render(request, "dashboard.html", context)

#to create a new poll
@login_required
def create_poll(request):
    #checks if the request is post
    if request.method=="POST":

        #gets the question of the poll
        question = request.POST.get("question")

        #gets a list of the choices
        choices = request.POST.getlist("choices")

        #create the poll object and use the create method to save directly to the database
        poll = Poll.objects.create(
            question=question,
            created_by=request.user,
        )

        #loop on the list that got for the choices
        for choice in choices:
            #create the choice object and save it to the database too
            new_choice = Choice.objects.create(
                poll=poll,
                choice_text=choice,
            )

        #redirect again to the dashboard with a success message
        messages.success(request, "Poll added successfully!")
        return redirect("dashboard")
    
    #if the request wasn't post then redirect to the create poll page with the username
    context = {
        "username": request.user.username,
    }
    return render(request, "create_poll.html", context)

#show all of the poll details
@login_required
def poll_details(request):
    #gets the poll id
    poll_id = request.GET.get("poll_id")

    #create an object of that poll id
    poll = Poll.objects.get(id=poll_id)

    #create a choice object of all of the choices on the db
    choices = Choice.objects.filter(poll_id=poll_id)

    # Prepare data for Chart.js
    choice_texts = []

    for choice in choices:
        choice_texts.append(choice.choice_text)

    vote_counts = []

    for choice in choices:
        vote_counts.append(choice.votes)


    #create the data that will be sent to the template
    context = {
        "username": request.user.username,
        "poll": poll,
        "choices":choices,
        "choice_texts":choice_texts,
        "vote_counts":vote_counts,
    }
    return render(request, "poll_details.html", context)

# a function generated by copilot to get the client ip address to be saved with the poll so a user don't spam on a poll
def get_client_ip(request):
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip = x_forwarded_for.split(',')[0]
    else:
        ip = request.META.get('REMOTE_ADDR')
    return ip

# vote to a poll
def vote_to_poll(request):
    
    #gets the poll id
    poll_id = request.GET.get("poll_id")

    #create an object of the poll with that poll_id
    poll = Poll.objects.get(id=poll_id)

    #create an object of the choices with that poll_id
    choices = Choice.objects.filter(poll_id=poll_id)

    #get the users ip address
    ip_address = get_client_ip(request)

    #if the request is a post request
    if request.method == "POST":
        #if this user that sends the request is already on the Votes table with the same ip and the same poll so we return an error for him
        if Vote.objects.filter(poll=poll, ip_address=ip_address):
            messages.error(request, "You have already voted on this poll.")
            return render(request,"vote_submit.html")
        
        #gets the users choice_id
        selected_choice_id = request.POST.get("selected_choice")

        #creates an object with that id of the users choice
        selected_choice = Choice.objects.get(id=selected_choice_id)

        #increase the number of choices by 1
        selected_choice.votes += 1

        try:
            #created a new object of the votes
            Vote.objects.create(poll=poll, ip_address=ip_address)
            #saves the new number of choices
            selected_choice.save()
            #send a success message for the user
            messages.success(request, "Your vote has been recorded!")
        except IntegrityError:
            #if something unexpected happens and a user make a poll again with the same ip and pass form the first check the db constrain will raise an error
            #so this will catch that error
            messages.error(request, "You have already voted on this poll.")

        #return a blank  page to show the message
        return render(request,"vote_submit.html")
    
    #if the user is with a get request he will render the html page with the poll context
    context = {
        "poll": poll,
        "choices":choices
    }
    return render(request, "vote_to_poll.html", context)